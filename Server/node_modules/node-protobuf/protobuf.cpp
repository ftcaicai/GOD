#include <v8.h>

#include <node.h>
#include <node_buffer.h>
#include <node_object_wrap.h>

#include <google/protobuf/dynamic_message.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/descriptor.pb.h>
#include <google/protobuf/service.h>

#include <iostream>
#include <sstream>
#include <iomanip>
#include <algorithm>
#include <string> 

using namespace google::protobuf;
using namespace v8;
using node::Buffer;
class Type;
class Protobuf;

static Persistent<String> KeySymbol;
static Persistent<String> ValueSymbol;
static Persistent<FunctionTemplate> TypeTemplate;

class Protobuf : public node::ObjectWrap {
public:
	static void Init(Handle<Object> exports);
	typedef std::map<const Descriptor*, Type*> TypeMap;
	typedef std::vector<Type*> TypeVector;

private:
	Protobuf(DescriptorPool *pool);
	~Protobuf();

	DescriptorPool *pool;
	DynamicMessageFactory factory;
	TypeVector handles;
	TypeMap mTypeMap;

public:
	Type* GetType(const Descriptor* descriptor);

	static Handle<v8::Value> New(const Arguments &args);
	static Handle<Value> Serialize(const Arguments &args);
	static Handle<Value> Parse(const Arguments &args);
	static Handle<Value> MessageHandle(const Arguments &args);
};

class Type : public node::ObjectWrap {
public:
	Protobuf* protobuf;
	google::protobuf::Message *message;
	const Descriptor* descriptor;
	size_t index;

	Type(Protobuf* _protobuf, google::protobuf::Message *_message, Handle<Object> self, size_t _index) {
		protobuf = _protobuf;
		message = _message;
		descriptor = _message->GetDescriptor();
		index = _index;

		// Generate functions for bulk conversion between a JS object
		// and an array in descriptor order:
		//   from = function(arr) { this.f0 = arr[0]; this.f1 = arr[1]; ... }
		//   to   = function()    { return [ this.f0, this.f1, ... ] }
		// This is faster than repeatedly calling Get/Set on a v8::Object.
		std::ostringstream from, to;
		from << "(function(arr) { if(arr) {";
		to << "(function() { return [ ";
		for (int i = 0; i < descriptor->field_count(); i++) {
			std::string name = descriptor->field(i)->name();
			from << "var x = arr[" << i << "]; if (x !== undefined) this['" << name << "'] = x; ";
			if (i > 0) to << ", ";
			to << "this['" << name << "']";
		}
		from << " }})";
		to << " ]; })";

		// managed type->schema link
		self->SetInternalField(1, protobuf->handle_);
		self->SetInternalField(2, Script::Compile(String::New(from.str().c_str()))->Run());
		self->SetInternalField(3, Script::Compile(String::New(to.str().c_str()))->Run());

		Wrap(self);
	}
	
#define GET_VALUE(TYPE)                                        \
      (index >= 0 ?                                            \
       r->GetRepeated##TYPE(message, field, index) :           \
       r->Get##TYPE(message, field))

	Handle<Value> ParseField(const google::protobuf::Message &message, const Reflection *r, const FieldDescriptor *field, int index) {
		switch (field->cpp_type()) {
		case FieldDescriptor::CPPTYPE_MESSAGE:
			return protobuf->GetType(field->message_type())->ParsePart(GET_VALUE(Message));
		case FieldDescriptor::CPPTYPE_STRING: {
			const string& value = GET_VALUE(String);
			if (field->type() == FieldDescriptor::TYPE_BYTES)
				return Buffer::New(const_cast<char *>(value.data()), value.length())->handle_;
			else
				return String::New(value.data(), value.length());
		}
		case FieldDescriptor::CPPTYPE_INT32:
			return Integer::New(GET_VALUE(Int32));
		case FieldDescriptor::CPPTYPE_UINT32:
			return Integer::NewFromUnsigned(GET_VALUE(UInt32));
		case FieldDescriptor::CPPTYPE_INT64:
			return Number::New(GET_VALUE(Int64));
		case FieldDescriptor::CPPTYPE_UINT64:
			return Number::New(GET_VALUE(UInt64));
		case FieldDescriptor::CPPTYPE_FLOAT:
			return Number::New(GET_VALUE(Float));
		case FieldDescriptor::CPPTYPE_DOUBLE:
			return Number::New(GET_VALUE(Double));
		case FieldDescriptor::CPPTYPE_BOOL:
			return Boolean::New(GET_VALUE(Bool));
		case FieldDescriptor::CPPTYPE_ENUM:
			return Integer::New(GET_VALUE(Enum)->number());
		}

		return Handle<Value>();  // NOTREACHED
	}

	Handle<Object> ParsePart(const google::protobuf::Message &message) {
		HandleScope scope;
		const Reflection* r = message.GetReflection();
		const Descriptor* descriptor = message.GetDescriptor();

		Local<Array> properties = Array::New(descriptor->field_count());
		for (int i = 0; i < descriptor->field_count(); i++) {
			const FieldDescriptor* field = descriptor->field(i);
			bool repeated = field->is_repeated();
			if (repeated && !r->FieldSize(message, field)) continue;
			if (!repeated && !r->HasField(message, field)) continue;

			Handle<Value> value;
			if (field->is_repeated()) {
				int size = r->FieldSize(message, field);
				Handle<Array> array = Array::New(size);
				for (int j = 0; j < size; j++)
					array->Set(j, ParseField(message, r, field, j));
				value = array;
			} else {
				value = ParseField(message, r, field, -1);
			}

			if (value->IsNull()) continue;

			properties->Set(i, value);
		}

		Local<Function> from_array = handle_->GetInternalField(2).As<Function>();

		Handle<Value> args = properties;
		return scope.Close(from_array->NewInstance(1, &args));
	}

#define SET_VALUE(TYPE, EXPR) \
	if (repeated) r->Add##TYPE(message, field, EXPR); \
	else r->Set##TYPE(message, field, EXPR);

	void SerializeField(google::protobuf::Message *message, const Reflection *r, const FieldDescriptor *field, Handle<Value> val) {
		const EnumValueDescriptor *enumValue = NULL;
		bool repeated = field->is_repeated();

		switch (field->cpp_type()) {
		case FieldDescriptor::CPPTYPE_INT32:
			SET_VALUE(Int32, val->Int32Value());
			break;
		case FieldDescriptor::CPPTYPE_INT64:
			SET_VALUE(Int64, val->NumberValue());
			break;
		case FieldDescriptor::CPPTYPE_UINT32:
			SET_VALUE(UInt32, val->Uint32Value());
			break;
		case FieldDescriptor::CPPTYPE_UINT64:
			SET_VALUE(UInt64, val->NumberValue());
			break;
		case FieldDescriptor::CPPTYPE_DOUBLE:
			SET_VALUE(Double, val->NumberValue());
			break;
		case FieldDescriptor::CPPTYPE_FLOAT:
			SET_VALUE(Float, val->NumberValue());
			break;
		case FieldDescriptor::CPPTYPE_BOOL:
			SET_VALUE(Bool, val->BooleanValue());
			break;
		case FieldDescriptor::CPPTYPE_ENUM:
			enumValue = val->IsNumber() ? 
				field->enum_type()->FindValueByNumber(val->Int32Value()) :
				field->enum_type()->FindValueByName(*String::AsciiValue(val));
			if (enumValue != NULL)
				SET_VALUE(Enum, enumValue);
			break;
		case FieldDescriptor::CPPTYPE_MESSAGE:
			if (val->IsObject()) {
				Type* type = protobuf->GetType(field->message_type());
				type->SerializePart(repeated ?
					r->AddMessage(message, field) :
					r->MutableMessage(message, field), val.As<Object>());
			}
			break;
		case FieldDescriptor::CPPTYPE_STRING:
			if (Buffer::HasInstance(val)) {
				Local<Object> buf = val->ToObject();
				SET_VALUE(String, std::string(Buffer::Data(buf), Buffer::Length(buf)));
			} else {
				String::Utf8Value utf8(val);
				SET_VALUE(String, std::string(*utf8, utf8.length()));
			}
			break;
		}
	}

	void SerializePart(google::protobuf::Message *message, Handle<Object> src) {
		Handle<Function> to_array = handle_->GetInternalField(3).As<Function>();
		Handle<Array> properties = to_array->Call(src, 0, NULL).As<Array>();
		const Reflection *r = message->GetReflection();
		for (int i = 0; i < descriptor->field_count(); i++) {
			Local<Value> value = properties->Get(i);
			if (value->IsUndefined() || value->IsNull()) 
				continue;

			const FieldDescriptor* field = descriptor->field(i);
			if (field->is_repeated()) {
				if (value->IsArray()) {
					Handle<Array> array = value.As<Array>();
					int length = array->Length();
					for (int j = 0; j < length; j++)
						SerializeField(message, r, field, array->Get(j));
				}
				else if (value->IsObject() && 
					field->cpp_type() == FieldDescriptor::CPPTYPE_MESSAGE && 
					field->message_type()->name().compare(0, 20, "KeyValuePair_String_") == 0) {
					Local<Object> object = value.As<Object>();
					Local<Array> subProperties = object->GetOwnPropertyNames();
					int len = subProperties->Length();
					for (int keyIdx = 0; keyIdx < len; keyIdx++) {
						Local<Object> keyValuePair = Object::New();
						Local<Value> key = subProperties->Get(keyIdx);
						keyValuePair->Set(KeySymbol, key);
						keyValuePair->Set(ValueSymbol, object->Get(key));
						SerializeField(message, r, field, keyValuePair);
					}
				}
			} else {
				SerializeField(message, r, field, value);
			}
		}
	}
};

Protobuf::Protobuf(DescriptorPool *pool) {
	this->pool = pool;
}

Protobuf::~Protobuf() {
	delete this->pool;
}

Type* Protobuf::GetType(const Descriptor* descriptor) {
	TypeMap::iterator it = mTypeMap.find(descriptor);
	if (it != mTypeMap.end())
		return it->second;
	Type* result = mTypeMap[descriptor] = 
		new Type(this,
		factory.GetPrototype(descriptor)->New(),
		TypeTemplate->GetFunction()->NewInstance(),
		handles.size());
	handles.push_back(result);

    Handle<Array> types = handle_->GetInternalField(1).As<Array>();
    types->Set(types->Length(), result->handle_);
	return result;
}

void Protobuf::Init(Handle<Object> exports) {
	// Prepare constructor template
	Local<FunctionTemplate> tpl = FunctionTemplate::New(New);
	tpl->SetClassName(String::NewSymbol("Protobuf"));
	tpl->InstanceTemplate()->SetInternalFieldCount(2);

	// Prototype
	tpl->PrototypeTemplate()->Set(String::NewSymbol("Serialize"), FunctionTemplate::New(Serialize)->GetFunction());
	tpl->PrototypeTemplate()->Set(String::NewSymbol("Parse"), FunctionTemplate::New(Parse)->GetFunction());
	tpl->PrototypeTemplate()->Set(String::NewSymbol("MessageHandle"), FunctionTemplate::New(MessageHandle)->GetFunction());

	Persistent<Function> constructor = Persistent<Function>::New(tpl->GetFunction());
	exports->Set(String::NewSymbol("Protobuf"), constructor);

	KeySymbol = NODE_PSYMBOL("Key");
	ValueSymbol = NODE_PSYMBOL("Value");

	TypeTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New());
    TypeTemplate->InstanceTemplate()->SetInternalFieldCount(4);
}

Handle<Value> Protobuf::New(const Arguments& args) {
	HandleScope scope;

	Local<Object> buffer_obj = args[0]->ToObject();
	char *buffer_data = Buffer::Data(buffer_obj);
	size_t buffer_length = Buffer::Length(buffer_obj);

	FileDescriptorSet descriptors;
	if (!descriptors.ParseFromArray(buffer_data, buffer_length)) {
		return v8::ThrowException(
			v8::Exception::Error(String::New("Malformed descriptor")));
	}

	DescriptorPool* pool = new DescriptorPool;
	for (int i = 0; i < descriptors.file_size(); i++)
		pool->BuildFile(descriptors.file(i));

	Protobuf* obj = new Protobuf(pool);
	args.This()->SetInternalField(1, Array::New());

	obj->Wrap(args.This());

	return args.This();
}

Handle<Value> Protobuf::Serialize(const Arguments &args) {
	HandleScope scope;

	Protobuf* obj = ObjectWrap::Unwrap<Protobuf>(args.This());

	// get object to serialize and name of schema
	Local<Object> subj = args[0]->ToObject();
	uint32_t handle = args[1]->Uint32Value();
	Local<Object> buffer_obj = args[2]->ToObject();
	char *buffer_data = Buffer::Data(buffer_obj);
	size_t buffer_length = Buffer::Length(buffer_obj);

	if (handle >= obj->handles.size())
		return v8::ThrowException(
		v8::Exception::Error(String::New("Handle is overflow!!!")));

	Type* type = obj->handles[handle];
	google::protobuf::Message *message = type->message;
	message->Clear();

	type->SerializePart(message, subj);

	// make JS Buffer instead of SlowBuffer
	int size = message->ByteSize();
	if (size >= buffer_length)
		return v8::ThrowException(
		v8::Exception::Error(String::New("Not Enough Buff Size")));

	google::protobuf::uint8* ret = message->SerializeWithCachedSizesToArray((google::protobuf::uint8*)buffer_data);
	return scope.Close(Integer::New(size));
}

Handle<Value> Protobuf::Parse(const Arguments &args) {
	HandleScope scope;

	Protobuf* obj = ObjectWrap::Unwrap<Protobuf>(args.This());

	Local<Object> buffer_obj = args[0]->ToObject();
	char *buffer_data = Buffer::Data(buffer_obj);
	size_t buffer_length = Buffer::Length(buffer_obj);

	uint32_t handle = args[1]->Uint32Value();
	if (handle >= obj->handles.size())
		return v8::ThrowException(
		v8::Exception::Error(String::New("Handle is overflow!!!")));

	Type* type = obj->handles[handle];
	google::protobuf::Message *message = type->message;
	type->message->ParseFromArray(buffer_data, buffer_length);
	Handle<Object> ret = type->ParsePart(*type->message);

	return scope.Close(ret);
}

Handle<Value> Protobuf::MessageHandle(const Arguments &args) {
	HandleScope scope;
	Protobuf* obj = ObjectWrap::Unwrap<Protobuf>(args.This());

	String::Utf8Value schemaName(args[0]->ToString());
	std::string schema_name = std::string(*schemaName);

	// create a message based on schema
	const Descriptor* descriptor = obj->pool->FindMessageTypeByName(schema_name);
	Type* type = obj->GetType(descriptor);

	return scope.Close(Uint32::New(type->index));
}

void init(Handle<Object> exports) {
	Protobuf::Init(exports);
}

NODE_MODULE(protobuf, init)
